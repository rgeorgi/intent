import logging

from intent.igt.igtutils import rgp
from intent.igt.metadata import set_intent_method
from xigt.model import Tier, Item

from intent.alignment.Alignment import heur_alignments
from intent.igt.rgxigt import find_gloss_word, gen_tier_id, gen_item_id
from intent.igt.search import get_pos_tags, get_trans_gloss_alignment, find_in_obj, delete_tier

ALIGN_LOG = logging.getLogger("ALN")
from .search import glosses, tier_tokens, gloss, trans, get_bilingual_alignment_tier, ask_item_id, item_index
from intent.consts import *

def set_bilingual_alignment(inst, src_tier, tgt_tier, aln, aln_method):
    """
    Specify the source tier and target tier, and create a bilingual alignment tier
    between the two, using the indices specified by the Alignment aln.

    :param src_tier: The tier that will be the source for bilingual alignments.
    :type src_tier: RGTier
    :param tgt_tier: The tier that will be the target for bilingual alignments.
    :type tgt_tier: RGTier
    :param aln: The alignment to be added
    :type aln: Alignment
    """

    # Look for any alignments previously generated by this method, and delete them
    # if found. Do NOT replace other alignments generated by other methods.
    prev_ba_tier = get_bilingual_alignment_tier(inst, src_tier.id, tgt_tier.id, aln_method)

    if prev_ba_tier:
        delete_tier(prev_ba_tier)

    # Just to make things neater, let's sort the alignment by src index.
    aln = sorted(aln, key = lambda x: x[0])

    # Start by creating the alignment tier.
    tier_id = gen_tier_id(inst, G_T_ALN_ID, tier_type=ALN_TIER_TYPE)
    ba_tier = Tier(id=tier_id,
                   type=ALN_TIER_TYPE,
                   attributes={SOURCE_ATTRIBUTE:src_tier.id,
                               TARGET_ATTRIBUTE:tgt_tier.id})

    # Add the metadata for the alignment source (intent) and type (giza or heur)
    set_intent_method(ba_tier, aln_method)

    for src_i, tgt_i in aln:
        src_token = src_tier[src_i-1]
        tgt_token = tgt_tier[tgt_i-1]

        add_pair(ba_tier, src_token.id, tgt_token.id)

    inst.append(ba_tier)

def add_pair(tier, src_id, tgt_id):
    attributes = {SOURCE_ATTRIBUTE:src_id, TARGET_ATTRIBUTE:tgt_id}
    i = find_in_obj(tier, attributes=attributes)
    if i is None:
        ba = Item(id=ask_item_id(tier), attributes=attributes)
        tier.append(ba)
    else:
        i.attributes[TARGET_ATTRIBUTE] += ',' + tgt_id

def heur_align_inst(inst, **kwargs):
    """
    Heuristically align the gloss and translation lines of this instance.
    :rtype Alignment:
    """

    # If given the "tokenize" option, use the tokens
    # split at the morpheme level

    if kwargs.get('tokenize', True):
        gloss_tokens = tier_tokens(glosses(inst))
    else:
        gloss_tokens = tier_tokens(gloss(inst))

    trans_tokens = tier_tokens(trans(inst))

    # Use POS tags from the classifier if available.
    if kwargs.get('use_pos', False):
        gloss_pos_tier = get_pos_tags(inst, gloss(inst).id, tag_method=INTENT_POS_CLASS)
        trans_pos_tier = get_pos_tags(inst, trans(inst).id, tag_method=INTENT_POS_TAGGER)

        if gloss_pos_tier is None:
            ALIGN_LOG.warn(ARG_ALN_HEURPOS + ' alignment requested, but gloss tags were not available. Skipping for instance {}.'.format(inst.id))
        if trans_pos_tier is None:
            ALIGN_LOG.warn(ARG_ALN_HEURPOS + ' alignment requested, but trans-tagger tags were not available. Skipping for instance "{}"'.format(inst.id))

        if not (gloss_pos_tier is None or trans_pos_tier is None):
            # TODO: In order to do the alignment with POS tags, they need to be at the morpheme level. Find a better way to do this?
            # Make sure to expand the POS tags to function at the morpheme-level...
            if kwargs.get('tokenize', True):
                glosses_tags = [gloss_pos_tier[item_index(find_gloss_word(inst, gloss))-1] for gloss in glosses(inst)]
                kwargs['gloss_pos'] = glosses_tags
            else:
                kwargs['gloss_pos'] = gloss_pos_tier

            kwargs['trans_pos'] = trans_pos_tier

    aln = heur_alignments(gloss_tokens, trans_tokens, **kwargs).flip()

    # -------------------------------------------
    # Set the appropriate method, based on whether
    # -------------------------------------------
    if kwargs.get('use_pos'):
        aln_method = INTENT_ALN_HEURPOS
    else:
        aln_method = INTENT_ALN_HEUR

    # -------------------------------------------
    # Now, add these alignments as bilingual alignments...
    # -------------------------------------------
    if kwargs.get('tokenize', True):
        set_bilingual_alignment(inst, trans(inst), glosses(inst), aln, aln_method=aln_method)
    else:
        set_bilingual_alignment(inst, trans(inst), glosses(inst), aln, aln_method=aln_method)

    return get_trans_gloss_alignment(inst, aln_method=aln_method)
